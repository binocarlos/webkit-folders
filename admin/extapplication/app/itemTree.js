////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// ItemTree.js
//
//
// creates a menu tree consisting of item elements
// reads the JSON item data from the server and creates TreeNodes from that
//
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



Webkit.Folders.ItemTree = Ext.extend(Ext.util.Observable, {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// INIT
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	nodeMap: {},
	systemNodeMap: {},
	
	state: {},
	stateName:'treeNodeState',
	
	//////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////
	// required params:
	//		id		= the id of this component
	//		name	= the title this component
	//		uri		= the data uri this component will use
		
    constructor: function(config)
    {
    	Ext.apply(this, config);
    	
        this.addEvents(
        	'afterrender',	// fired when the tree has rendered
        	'loaddata',		// we want the tree data
        	'loaditem', 	// an item in the tree was selected
        	'moveitems'		// some items have been dropped onto another
        );
        
        this.provider = new Ext.state.CookieProvider();
        this.state = this.provider.get(this.stateName, {});

        Webkit.Folders.ItemTree.superclass.constructor.call(config);
        
        this.createGUI();
        
        this.stateName = this.id + 'treeState';
	},
		
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// EVENTS
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	

	
	//////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////
	// triggers when an item from the treePanel has been clicked
	// this in turn fires our showitem event
	
	treeClicked : function(node, e)
	{
		this.fireEvent('loaditem', node.attributes.item, this);
	},
	
	getParentItem: function(item)
	{
		var itemNode = this.panel.getNodeById(item.id);
		
		var itemParentNode = itemNode.parentNode;
		
		return itemParentNode.attributes.item;
	},
	
	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// PUBLIC INTERFACE
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	
	
	
	reloadEntireTree: function()
	{
		//this.loader.load(this.rootNode);
	},
	
	initTree: function(rootFolderInfo)
	{
		var rootItem = new Webkit.Folders.Item(rootFolderInfo, rootFolderInfo.id);
		
		this.rootNode = this.createTreeNode(rootItem);
		
		this.panel.setRootNode(this.rootNode);
		
		this.nodeLoadingChildren = this.rootNode;
		this.fireEvent('loaddata', this.rootNode.id);
	},
	
	setInstallationName: function(installationName)
	{
		this.panel.setTitle(installationName);
	},
	
	//////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////
	// an items title has changed so we should update the treeNode with its new name
	
	renameItem : function(item)
	{
		var treeNode = this.panel.getNodeById(item.id);
		
		if(treeNode==null) { return; }
		
		treeNode.attributes.name = item.get('name');
		treeNode.setText(item.get('name'));
		
		var parentNode = treeNode.parentNode;
		
		// we need to sort out sorting : ) before we can do this
		if(parentNode)
		{
			//this.sortNode(parentNode);
		}
	},
	
	
	//////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////
	// returns an array of objects starting from the root node that lead to the given item
	// if the item is not a folder then its parent is the starting poing

	getItemPath : function(item)
	{
		var destinationNode = this.panel.getNodeById(item.id);
		
		if(!destinationNode)
		{
			destinationNode = this.panel.getNodeById(item.get('parent_id'));
		}
		
		if(!destinationNode)
		{
			return [];
		}
		
		var itemArray = [destinationNode.attributes.item];
		var returnArray = [];
		
		var currentNode = destinationNode.parentNode;
		
		while(currentNode)
		{
			itemArray.push(currentNode.attributes.item);
			
			currentNode = currentNode.parentNode;
		}
		
		for(var i=itemArray.length-1; i>=0; i--)
		{
			if(itemArray[i])
			{
				returnArray.push(itemArray[i]);
			}
		}
		
		return returnArray;
	},
	
	//////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////
	// expands and selects the given node
	
	highlightItem : function(item)
	{
		var theNode = this.panel.getNodeById(item.id);
		
		if(!theNode) { return; }
		
		if(theNode.hasChildNodes())
		{
			theNode.expand();
		}
		
		if(this.allowedToHighlight)
		{
			Ext.fly(theNode.getUI().getTextEl()).highlight("ffffff", { attr: 'color', duration: 1 });
		}
		
		this.allowedToHighlight = true;
		
		theNode.select();
	},
	
	removeNodeById: function(id)
	{
		var theNode = this.panel.getNodeById(id);

		if(theNode)
		{
			this.removeTreeNode(theNode);
		}
	},
	
	moveItemsToFolderById: function(dropId, dragIds)
	{
		var dropNode = this.panel.getNodeById(dropId);
		
		if(!dropNode)
		{
			return;
		}
		
		var dragItems = [];
		
		for(var i=0; i<dragIds.length; i++)
		{
			var dragNode = this.panel.getNodeById(dragIds[i]);
			
			if(!dragNode)
			{
				return;
			}
			
			dragItems.push(dragNode.attributes.item);
		}
		
		this.moveItemsToFolder(dropNode.attributes.item, dragItems);
	},
	
	moveItemToFolderById: function(dropId, dragId, allCopies)
	{
		var dropNode = this.panel.getNodeById(dropId);
		var dragNode = this.panel.getNodeById(dragId);
		
		if((!dropNode)||(!dragNode)) { return; }
		
		this.moveItemsToFolder(dropNode.attributes.item, [dragNode.attributes.item], allCopies);
	},
	
	// pass trueGhosts if you only want ghosts that belong to exactly the same parent
	
	getGhostNodesForItem: function(item, trueGhosts)
	{
		var ret = this.nodeMap[item.databaseId()];
		if(!ret)
		{
			return [];
		}
		var newRet = [];
		if(trueGhosts)
		{
			for(var i=0; i<ret.length; i++)
			{
				var ghostNode = ret[i];
				var ghostItem = ghostNode.attributes.item;
				
				if(item.parentDatabaseId()==ghostItem.parentDatabaseId())
				{
					newRet.push(ghostNode);
				}
			}
			
			return newRet;
		}
		else
		{
			return ret;
		}
	},
	
	//////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////
	// detatches the given nodes and moves them to the dropItemNode
	// it does this by first issuing the remove and then reloading
	// the drop node to grab any new ids that have been created
	
	moveItemsToFolder: function(dropItem, dragItems, allCopies)
	{
		if(dragItems==null) { return; }
		
		var dropNode = this.panel.getNodeById(dropItem.id);
		
		for(var i=0; i<dragItems.length; i++)
		{
			var justGhosts = true;
			
			if(allCopies)
			{
				justGhosts = false;
			}
			
			var ghostDragNodes = this.getGhostNodesForItem(dragItems[i], justGhosts);
			
			for(var j=0; j<ghostDragNodes.length; j++)
			{
				var ghostDragNode = ghostDragNodes[j];
				
				if(ghostDragNode)
				{
					this.removeTreeNode(ghostDragNode);
				}
			}
		}
		
		this.reloadTreeNode(dropNode);
	},
	
	copyItemsToFolder: function(dropItem, dragItems)
	{	
		if(dragItems==null) { return; }
		
		var dropNode = this.panel.getNodeById(dropItem.id);
	
		this.reloadTreeNode(dropNode);
	},
	
	reloadItemId: function(id)
	{
		var treeNode = this.panel.getNodeById(id);
		
		this.reloadTreeNode(treeNode);
	},
	
	reloadTreeNode: function(reloadNode)
	{
		var reloadItem = reloadNode.attributes.item;
		
		var ghostNodes = this.getGhostNodesForItem(reloadItem);
		
		for(var i=0; i<ghostNodes.length; i++)
		{
			this.reloadTreeNodeGhost(ghostNodes[i]);
		}
	},
	
	reloadTreeNodeGhost: function(reloadNode)
	{
		//while (reloadNode.hasChildNodes())
		//{
		//	this.removeTreeNode(reloadNode.item(0));
		//}
		
		this.fireEvent('loaddata', reloadNode.id);
	},
	
	nodeExpanded: function(node)
	{
		this.state[node.id] = 'E';
		this.saveState();
	},
   
	nodeCollapsed: function(node)
	{
		this.state[node.id] = 'C';
		this.saveState();
	},
	
	saveState : function(newState)
	{
		this.state = newState || this.state;
		this.provider.set(this.stateName, this.state);
	},
	
	//////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////
	// main GUI building method
	//
	// it accepts a pre-built item as its arguments	

	createTreeNode: function(item)
	{
		var attr = {};

		attr.id = item.id;
		attr.name = item.get('name');
		attr.leaf = item.get('leaf');
		attr.item = item;
		attr.text = attr.name;
		
		if(Ext.isIE)
		{
			var iconURI = Webkit.Folders.IconFactory.makeItemIconURI(item, {
				destination:'tree'
			});
			
			attr.icon = iconURI;
		}
		else
		{
			var iconClass = Webkit.Folders.IconFactory.makeItemIconClass(item, {
				destination:'tree'
			});
			
			attr.iconCls = iconClass;
		}
		
		if(this.state[item.id]=='E')
		{
			attr.expanded = true;
		}
		
		if(item.shouldAutoExpand())
		{
			attr.expanded = true;
		}

		var treeNode = new Ext.tree.TreeNode(attr);

		if(this.nodeMap[item.databaseId()]==null)
		{
			this.nodeMap[item.databaseId()] = [];
		}
		
		this.nodeMap[item.databaseId()].push(treeNode);
		
		var children = item.getChildren();
		
		for(var i=0; i<children.length; i++)
		{
			var childItem = children[i];
			
			var childNode = this.createTreeNode(children[i]);
			
			treeNode.appendChild(childNode);
		}
		
		// lets auto expand their disk
		if(item.shouldAutoExpand())
		{
			if(!this.hasFiredAutoOpen)
			{
				this.hasFiredAutoOpen = true;
				treeNode.fireEvent.defer(100, treeNode, ['click', treeNode]);
			}
		}
	
		return treeNode;
	},
	
	clearTreeNodeReferences: function(treeNode)
	{
		var item = treeNode.attributes.item;
		
		var existingNodeArray = this.nodeMap[item.databaseId()];
		var newNodeArray = [];
		
		for(var i=0; i<existingNodeArray.length; i++)
		{
			var existingNode = existingNodeArray[i];
			
			if(existingNode.id != treeNode.id)
			{
				newNodeArray.push(existingNode);
			}
		}
		
		this.nodeMap[item.databaseId()] = newNodeArray;
	},
	
	removeTreeNode: function(treeNode)
	{
		this.clearTreeNodeReferences(treeNode);
		
		if(treeNode.ownerTree && treeNode.childNodes)
		{
			treeNode.remove();
		}
	},
	
	getSystemItems: function(type)
	{
		return this.systemNodeMap[type];
	},
   
	// this is passed items - i.e. things are already constructed
	// id is the node to add the results to
	addTreeData: function(treeData, id)
	{
		if(!this.panel.getEl()) { return; }
		
		var nodeToAddChildrenTo = this.panel.getNodeById(id);
		
		if(!nodeToAddChildrenTo)
		{
			nodeToAddChildrenTo = this.panel.root;
		}
		
		var currentNodeIndex = 0;
		
		// lets build a map of the data we have
		var treeDataMap = {};
		
		for(var i=0; i<treeData.length; i++)
		{
			var item = treeData[i];
			
			treeDataMap[item.id] = item;
		}
		
		// nows lets remove any nodes that exist that are not in the data
		for(var i=0; i<nodeToAddChildrenTo.childNodes.length; i++)
		{
			var childNode = nodeToAddChildrenTo.childNodes[i];
			
			if(!treeDataMap[childNode.id] && !childNode.attributes.manuallyAdded)
			{
				childNode.remove();
			}
		}

		for(var i=0; i<treeData.length; i++)
		{
			var item = treeData[i];
			
			if(item.isSystemObject())
			{
				var arr = this.systemNodeMap[item.getType()];
				
				if(arr==null)
				{
					arr = [];
				}
				
				arr.push(item);
				
				this.systemNodeMap[item.getType()] = arr;
			}
			
			var nextTreeNode = nodeToAddChildrenTo.childNodes[currentNodeIndex];
			
			var existingNode = this.panel.getNodeById(item.id);
		
			if(!existingNode)
			{
				var node = this.createTreeNode(item);
			
				nodeToAddChildrenTo.insertBefore(node, nextTreeNode);
			}
			else
			{
				if(existingNode.attributes.item.getIcon() != item.getIcon())
				{
					this.clearTreeNodeReferences(existingNode);
					
					var newNode = this.createTreeNode(item);
					
					var parentNode = existingNode.parentNode;
					
					parentNode.replaceChild(newNode, existingNode);
					
					this.fireEvent('loaddata', newNode.id);
				}
				else
				{
					existingNode.attributes.item = item;
					existingNode.setText(item.name);
				}
			}
			
			currentNodeIndex++;
		}
		
		var leaf = true;
		
		if(treeData.length>0)
		{
			leaf = false;
		}
		
		nodeToAddChildrenTo.leaf = leaf;
		nodeToAddChildrenTo.expand();
	},
	
	
		
	
	sortNode: function(node)
	{
		var sorter = function(a, b)
		{
			var v1 = a.text.toLowerCase();
			var v2 = b.text.toLowerCase();
			
			return v1 > v2 ? 1 : (v1 < v2 ? -1 : 0);	
		}
		
		node.sort(sorter);
	},
    
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// GUI
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	
	//////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////
	// creates a dragZone with the given dragGroup
	
	createDDZones : function(ddGroup)
	{
		if(!this.panel.getEl()) { return; }
		this.dropZone = new Webkit.Folders.ItemTreeDropZone(this, {
			ddGroup: ddGroup || this.id + '-dd'
		});
	},
	
	
	createGUI : function()
	{
		var rootNodeIconClass = Webkit.Folders.IconFactory.makeIconClass({
			name:'folder',
			destination:'tree'
		});
		
		this.rootNode = new Ext.tree.TreeNode({
			text: this.rootFolderName,
			name: this.rootFolderName,
			expanded: false,
			iconCls: this.rootNodeIconClass || rootNodeIconClass,
			id: this.rootFolderId || 'root'
        });
        
        var cfg = {
			id: this.id,
        	region: 'west',
        	enableDrop: this.itemDropEnabled,
        	border:false,
        	style:'border-right: #99bbe8 1px solid;',
        	bodyStyle:'background-color: #ffffff;',
        	width: 220,
        	autoScroll: true,
        	split: true,
        	loader: this.loader,
        	rootVisible: true,
        	root: this.rootNode
		};
		
		if(this.renderConfig)
		{
			cfg.renderTo = this.renderConfig.tree.div;
		}
		
		if(!this.noHeader)
		{
			cfg.collapsible = true;
        	cfg.title = this.name;		
		}
        
		this.panel = new Ext.tree.TreePanel(cfg);
		
		this.createEventListeners();	
    },
    
	//////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////
	// maps component events onto functions
	
	createEventListeners : function()
	{
		// listens for a click on the treePanel
		this.panel.addListener('click', this.treeClicked, this);
		
		this.panel.addListener('collapsenode', this.nodeCollapsed, this);
		this.panel.addListener('expandnode', this.nodeExpanded, this);
		
		this.panel.addListener('afterrender', this.treeRendered, this);
	},
	
	treeRendered: function()
	{
		this.fireEvent('afterrender');	
	}
});





























////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// ItemTreeDropZone
//
// This enables things to be dragged into the tree
// it will check if this is sensible
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Webkit.Folders.ItemTreeDropZone = function(itemTree, config)
{
	this.itemTree = itemTree;
	
    Webkit.Folders.ItemTreeDropZone.superclass.constructor.call(this, this.itemTree.panel.getEl(), config);
};

Ext.extend(Webkit.Folders.ItemTreeDropZone, Ext.dd.DropZone, {
	
	//////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////
	// This is where you compare an item being dropped onto a tree node to
	// see if this option is allowed - for instance dropping a folder on itself
    
	isValidDropPoint: function(node, data)
	{
		var dropNode = this.itemTree.panel.getNodeById(node.node.attributes.id);
		var dropItem = dropNode.attributes.item;
		
		var dropAttributes = dropNode.attributes;
		
		var dragItems = data.items;
		
		for(var i=0; i<dragItems.length; i++)
		{
			var dragItem = dragItems[i];
			var dragNode = this.itemTree.panel.getNodeById(dragItem.id);
			
			if(dragNode)
			{
				var parentDragNode = dragNode.parentNode;
				var parentDragItem = parentDragNode.attributes.item;
			
				if(!dragItem.canMove(parentDragItem)) { return false; }
			}
			
			if(!dropItem.canAddItem(dragItem)) { return false; }
			
			if(dragNode)
			{
				var dragGhosts = this.itemTree.getGhostNodesForItem(dragItem);
		
				for(var j=0; j<dragGhosts.length; j++)
				{
					var dragGhost = dragGhosts[j];
				
					if(dropItem.isAncestor(dragGhost.attributes.item))
					{
						return false;	
					}
				}
			}
		}
		
		return true;
	},
	
	//////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////
	// Changes the icon depending whether it is a good drop point or not
	
	onNodeOver: function(n, dd, e, data)
	{
		var returnCls = this.dropNotAllowed;

		if(this.isValidDropPoint(n, data))
		{
			returnCls = this.dropAllowed;
		}
		
		return returnCls;
	},
	
	
	//////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////
	// Triggered when data is dropped onto the tree
	
	onNodeDrop : function(node, dd, e, data)
	{
		var dropNode = this.itemTree.panel.getNodeById(node.node.attributes.id);
		var dropItem = dropNode.attributes.item;
		
		var dropAttributes = dropNode.attributes;
		
		var dragItems = data.items;
		
		if(!this.isValidDropPoint(node, data)) { return; }
		
		this.itemTree.fireEvent('moveitems', dropItem, data.items, this.itemTree);
	}	
	
});